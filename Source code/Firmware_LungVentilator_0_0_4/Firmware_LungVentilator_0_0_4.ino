/*........................  Firmware  System for Emergency Lung Ventilator v 0.0.4   2020/05/13  Set-up: 4 STEPPER Motors & 2 BT6600 drivers / 2 limitswitchers / 1 I2C 16x2 Monochromatic display / 3x analog potenciometer / 2x standard switches  Written by: DEX Innovation Centre*//*  Current version includes:  - Homing of both Arms, but not separately   - Pressing bag by very basic code, without any adjustments to the real inputs  - I2C Monochramic display integrated  - Analog potentiometer control integrated  - Set-up of operation values including visualisation at Display  - Controls of the System, basic functionality (depends on the readiness of the prototype)  - READY TO SET-UP FOR PRESSIRNG REAL TIDAL VOLUME    - Version was tested at the prototype NO.2*//*Next version: - Control of Respiratory Rate and of the I/E ( to be still included to 0.0.4 version)- Fundamnetal redesign thanks to reading of one switcher ( possibility to change the values and home during the operation)- Arms management:   - homing specifically for each ARM (independent management of the drivers)  - permanent check of the ARM during opening to avoid openin beyond the HOME position    *//*A ISSUES FOUND  - FUNDAMENTAL ISSUE:  By desing, we are running two independent arms as connected system (2 drivers connected as paralel ones). AS the result, we can not control Arms independently  which also mean, that we can not found precise home. It's hard to say how much this limit systems, but probably YES.Possible mitigation strategies:     - Run driver for each Arm separately. It will cost us 2 PINs and it will mean the possible risk of not having enough PINS ! it could be overcome by shield or Arduino Mega     - Change the mechanical design to joint operating of gear mechanism. It will mean risk for whole design (so preferably for next version)*/#include <AccelStepper.h>#include <Wire.h>#include <LiquidCrystal_I2C.h>/*DEFINE THE PIN'S WIRING FOR THE WHOLE SYSTEM  DIR for BT6600 drivers (connected in series) - PIN 2  STEP for BT6600 drivers (connected in series) - PIN 3  LEFT LIMIT SWITCH (looking from the head of Bag - head is the side connected to lung/patient) - PIN 8  RIGHT LIMIT SWITCH (looking from the head of Bag - head is the side connected to lung/patient) - PIN 9  I2C Display SCL connection - SCL PIN   I2C Display SDA connection - SDA PIN   Left / AirVolume Potentiometer - A1 PIN  Middle / RRValue Potentiometer - A2 PIN  Rigth / IERatio Potentiometer - A3 PIN   */  #define dirPin 2#define stepPin 3#define Left_Limit_Switch 7#define Right_Limit_Switch 8#define AirVolume_PIN  A1#define RRValue_PIN A2#define IERatio_PIN A3// Create a new instance of the AccelStepper class:AccelStepper CAMArms = AccelStepper(1, stepPin, dirPin);//Create a new instance for MonoChromatic I2C DisplayLiquidCrystal_I2C lcd(0x27, 16, 2);//definition of supportive variableslong Long_i = 1; // Used to: i) homing CAMArms ; ii) Supportive variable to run the definition loop for the inputs// global variables defining key parameters for the ventilationint TidalVolume; // Tidal Volume (TV) (air volume pushed into lung): between 200 – 800 mL based on patient weight.int RRValue; // Respiratory Rate (RR) (breaths per minute): between 6 – 40. Note that the low RRs of 6 – 9 are only applicable to Assist Control.float IERatio; // (inspiratory/expiration time ratio): recommended to start around 1:2; best if adjustable between range of 1:1 – 1:3*./*-------------------------FOR TESTING PURPOSES ONLY --------------------------------------------------*/unsigned long time;void setup() {  // just for testing  Serial.begin(9600);   // just for testing     //Initialization screen for the DEX IC VENT  lcd.init();  lcd.begin(16,2);  lcd.backlight();    lcd.setCursor(3,0);   lcd.print("DEX-IC VENT");   lcd.setCursor(5,1);  lcd.print("Welcome");  delay(3000);  lcd.clear();    //set-up of the text, which will stay on the screen permanenty  lcd.setCursor (2,0);  lcd.print("T. Volume ");  lcd.setCursor (0,1);  lcd.print("RR ");  lcd.setCursor (7,1);  lcd.print("I/E 1: ");      // just for testing  time=0;  // just for testing      //start of the reading of the inputs from the Potentiometers  while (time<20000) /// BE AWARE FOR CURRENT VERSION THERE IS 20.000 of miliseconds to set-up the system, then it starts automatically. If you need to shorten or prolong, please change the variable here   {    // reading of the Tidal (Air) Volume, while linear conversion rate is applied. The limits: 200 - 800 ml    lcd.setCursor(13,0);    int A1Reading = analogRead(AirVolume_PIN);    TidalVolume=200+A1Reading/1.705; // HERE CHANGE IF YOU NEED TO CHANGE THE RATIO    lcd.print(TidalVolume);        //reading of the RR (Respiratory Rate), while linear conversion rate is applied. The limits: 6 - 40 RR per minute     lcd.setCursor(3,1);    int A2Reading = analogRead(RRValue_PIN); // HERE CHANGE IF YOU NEED TO CHANGE THE RATIO    RRValue=6+A2Reading/30;    if (RRValue < 10) {      lcd.print("0");      lcd.print(RRValue);    }    else {      lcd.print(RRValue);     }        // reading of the Expiratory value, while linear conversion rate is applied. The limits of I/E are from 1:1 to 1:3    lcd.setCursor(13,1);    int A3Reading = analogRead(IERatio_PIN);    IERatio=1.0+A3Reading/510.0; // HERE CHANGE IF YOU NEED TO CHANGE THE RATIO    lcd.print(IERatio);           /*  -------------------------  FOR TESTING PURPOSES ONLY   -------------------------  -------------------------  */     time = millis();   }  //Homing of both Arms  pinMode(Left_Limit_Switch, INPUT);  pinMode(Right_Limit_Switch, INPUT);  delay(10);  //  Set Max Speed and Acceleration of each Steppers at startup for homing  /* Start Homing procedure of Stepper Motor at startup     Our issue is that we have both drivers connected in paralel. It means, that we are not able to manipulate with Left Arm independently from Right Arm     Therefore the algorithm is as follows:      - we will home the Left Arm first      - then we will check the Right Arm, if it's in HOME position      - if not, we will be opening both Arms till the Right Arm is also homed... (not perfect procedure)      Solution: i) connected arms by opening / closing mechanism; ii) independent connection for both Arms (which will require 2 PINs to be additionally connected)      POSSIBLE ISSUE: we shall check and allocate the PINs to ensure that we have enough PINs available for the whole system  */  CAMArms.setMaxSpeed(150);  // Homing of the Left_Arm  while (!digitalRead(Left_Limit_Switch) && !digitalRead(Right_Limit_Switch)) {  // CAMArm is opening till it hits the switch    CAMArms.moveTo(Long_i);  // Set the position to move to    CAMArms.setSpeed(40);  // Set Speed of Stepper (Slower to get better accuracy)    Long_i++;  // Decrease by 1 for next move if needed    CAMArms.run();  // Stepper does 1 step (possibility to test to decrease stepping to 1/2 step)    delay(5);  }  delay(3000);  //Check of the Right_Arm - is it in the home position?  if (!digitalRead(Right_Limit_Switch)) {    // Limit Swith of Right CAM Arm is not yet pressed so the following codes further open the Arms    while (!digitalRead(Right_Limit_Switch)) {  // CAMArm is opening till it hits the switch      CAMArms.moveTo(Long_i);  // Set the position to move to      CAMArms.setSpeed(40);  // Set Speed of Stepper (Slower to get better accuracy)      Long_i++;  // Decrease by 1 for next move if needed      CAMArms.run();  // Stepper does 1 step (possibility to test to decrease stepping to 1/2 step)      delay(5);    }  }  delay(3000);  // The both Limit Switches are pressed now, while (teoretically, practically I worry, it can be much different becaue of missing the steps) left CAM Arm shall be pressed more,  // So we will be opening only the Left Arm, asuming Right Arm will open automatically more. NOTE: This is not fully precise Homing process.  while (digitalRead(Left_Limit_Switch)) { // Make the Stepper move CW until the switch is deactivated    CAMArms.moveTo(Long_i);    CAMArms.setSpeed(-40);  // Set Speed of Stepper (Slower to get better accuracy)    CAMArms.run();    Long_i--;    delay(5);  }    delay(3000);  for (int count = 0; count <60; count++) { // Change CONSTANT 60 to adjust the arms to be just touching limit switch     CAMArms.moveTo(Long_i);    CAMArms.setSpeed(-40);  // Set Speed of Stepper (Slower to get better accuracy)    CAMArms.run();    Long_i--;    delay(5);  }    // Arms are in HOME POSITION  //--------------------------  CAMArms.setCurrentPosition(0);  delay(3000);  }void loop() {    /* TO BE SET-UP BASED ON THE REAL READINGS FOR THE TIDAL VOLUME   The TidalVolume is integral value which is set in the ration from 200 to 800 ml. The objective is that system flows correct amount of the air volume.   The current function is linear one, while 200 ml was set-up to be equal position -60 and 800 ml was to be equal to - 160  For changes modify the standard linear mapping equation( values 6 and 60)  =(TidalVolume-200)/6+60  How to work with mapping: Tidal Volume is from 200 to 800 (600 values), while ArmPosition is assumed to be from 60 to 160. It means that EACH CHANGE OF 1 FOR ARM MEANS CHANGE   OF 6 IN TIDAL VOLUME. 60 represents the arm position for lowest tidal volume (200 ml), so if it is not true, then redefine it.   */  int ArmPosition = (TidalVolume-200)/6+60;  /    // Set the current position to 0:  CAMArms.setCurrentPosition(0);  CAMArms.setSpeed();  // This code is CLOSING ARM  // TO Stefan: if the ARMS are closing too much change to HIGHER number (i.e. -100); if too LOWER NUMBER (i.e. -150)  while (CAMArms.currentPosition() != -ArmPosition)  {    CAMArms.setSpeed(-80);// this number regulates the speed of closing the arms    CAMArms.runSpeed();  }  delay(1000);  //THIS CODE IS OPENING ARM  while (CAMArms.currentPosition() != 0) //this number shall be reverse to the function while for opening arm  {    CAMArms.setSpeed(80); // this number regulates the speed of opening the arms    CAMArms.runSpeed();  }  delay(1000);}